document.addEventListener('DOMContentLoaded', async () => {

            // --- 1. Render Banlist Section ---
            // --- CARD POPUP AND IMAGE FETCHER SCRIPT ---
            // Load cards first so they're in the cache for banlist auto-extraction
            CardLoader.loadCards({
                'lukias-img-container': 'Dracotail Lukias',
                'mululu-img-container': 'Dracotail Mululu',
                'gulamel-img-container-combo': 'Dracotail Gulamel',
                'gulamel-img-container': 'Dracotail Gulamel',
                'traps-img-container': 'Dracotail Horn', // Use one trap as representative
                'gulamel-predator-img': 'Dracotail Gulamel',
                'arthalion-predator-img': 'Dracotail Arthalion',
                'shaurus-predator-img': 'Dracotail Shaurus'
            });
            await CardLoader.renderBanlistSection('banlist-status', [
                'Dracotail Lukias',
                'Dracotail Mululu',
                'Dracotail Gulamel',
                'Dracotail Hortal',
                'Dracotail Arthalion',
                'Dracotail Shaurus',
                'Dracotail Horn',
                'Dracotail Flame',
                'Dracotail Sting',
                'Retaliating "C"'
            ], {
                archetypeName: 'Dracotail',
                relatedCards: ['Branded Fusion', 'El Shaddoll Winda'],
                archetypeTraits: {
                    coreMechanic: 'Fusion-focused strategy with multi-card type Fusion Summons',
                    supportReliance: 'moderate reliance on Fusion support cards',
                    adaptability: 'compact engine that adapts to various meta environments',
                    resilience: 'strong recovery through GY recursion and Fusion summoning flexibility'
                }
            });

            // --- 2. Load Card Images ---
            

            // --- 2. Initialize Banner Animation ---
            const canvas = document.getElementById('fusion-vortex-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                let particles = [];
                const numParticles = 150;
                let canvasWidth = canvas.offsetWidth;
                let canvasHeight = canvas.offsetHeight;
                let centerX = canvasWidth / 2;
                let centerY = canvasHeight / 2;

                const setCanvasSize = () => {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                    canvasWidth = canvas.width;
                    canvasHeight = canvas.height;
                    centerX = canvasWidth / 2;
                    centerY = canvasHeight / 2;
                };

                class Particle {
                    constructor() {
                        this.reset();
                    }
                    reset() {
                        this.x = centerX;
                        this.y = centerY;
                        this.angle = Math.random() * Math.PI * 2;
                        this.radius = Math.random() * (Math.min(canvasWidth, canvasHeight) / 2);
                        this.speed = (Math.random() * 0.02) + 0.01; // Angular speed
                        this.size = Math.random() * 2 + 1;
                        this.color = Math.random() > 0.5 ? '#fcd34d' : '#a78bfa'; // Gold or Violet
                        this.alpha = Math.random() * 0.5 + 0.2;
                    }
                    update() {
                        this.angle += this.speed;
                        this.radius -= 0.5; // Move towards center
                        if (this.radius <= 0) {
                            this.reset();
                            this.radius = Math.min(canvasWidth, canvasHeight) / 2; // Start from outside
                        }
                        this.x = centerX + Math.cos(this.angle) * this.radius;
                        this.y = centerY + Math.sin(this.angle) * this.radius;
                    }
                    draw() {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fillStyle = this.color;
                        ctx.globalAlpha = this.alpha;
                        ctx.fill();
                        ctx.closePath();
                    }
                }

                function initParticles() {
                    particles = [];
                    for (let i = 0; i < numParticles; i++) {
                        particles.push(new Particle());
                    }
                }

                function animate() {
                    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                    ctx.globalAlpha = 1;
                    particles.forEach(p => {
                        p.update();
                        p.draw();
                    });