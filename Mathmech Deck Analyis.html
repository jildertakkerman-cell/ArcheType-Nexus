document.addEventListener('DOMContentLoaded', async () => {
        // --- Render Banlist Section ---
        // --- CARD POPUP AND IMAGE FETCHER SCRIPT ---
            // Load cards first so they're in the cache for banlist auto-extraction
            CardLoader.loadCards({
            'circular-img-container': 'Mathmech Circular',
            'alembertian-img-container': 'Primathmech Alembertian',
            'superfactorial-img-container': 'Mathmech Superfactorial',
            'laplacian-img-container': 'Primathmech Laplacian',
            'heatsoul-img-container': 'Decode Talker Heatsoul',
            'terahertz-img-container': 'Firewall Dragon Darkfluid - Neo Tempest Terahertz'
        });
            await CardLoader.renderBanlistSection('banlist-status', [
            'Mathmech Circular',
            'Mathmech Nabla',
            'Mathmech Sigma',
            'Mathmech Diameter',
            'Mathmech Addition',
            'Mathmech Subtraction',
            'Mathmech Multiplication',
            'Mathmech Division',
            'Mathmech Equation',
            'Mathmech Superfactorial',
            'Mathmech Final Sigma'
        ], {
            archetypeName: 'Mathmech',
            relatedCards: [
                'Accesscode Talker',
                'Transcode Talker',
                'Update Jammer',
                'Splash Mage',
                'Firewall Dragon Darkfluid'
            ],
            archetypeTraits: {
                coreMechanic: 'Mathmech operates as a Cyberse OTK engine that builds toward powerful Extra Deck monsters through mathematical-themed effects and Link climbing strategies.',
                supportReliance: 'The deck is critically dependent on Mathmech Circular as its primary one-card starter and benefits heavily from generic Cyberse Link support.',
                adaptability: 'Mathmech can function as a Cyberse engine in hybrid builds or standalone as an aggressive combo deck.',
                resilience: 'The limitation of Mathmech Circular significantly weakens consistency, forcing reliance on backup starters and extenders.',
                keyLoss: 'Mathmech Circular being Limited to 1 copy drastically reduces the deck\'s ability to consistently execute its combo lines, requiring players to incorporate more diverse starters.',
                alternativeStrategy: 'Utilize backup starters like Parallel Exceed and Cynet Mining while incorporating additional Cyberse engines to maintain combo viability when Circular isn\'t available.'
            }
        });

        // --- ANIMATED BANNER SCRIPT ---
        const canvas = document.getElementById('grid-banner');
        if(canvas) {
            const ctx = canvas.getContext('2d');
            let width, height;
            let lines = [];
            const lineColor = 'rgba(255, 121, 0, 0.2)';
            const nodeColor = 'rgba(0, 229, 255, 0.4)';

            function resize() {
                width = canvas.width = canvas.offsetWidth;
                height = canvas.height = canvas.offsetHeight;
                lines = [];
                for (let i = 0; i < 40; i++) {
                    lines.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5
                    });
                }
            }

            function draw() {
                ctx.clearRect(0, 0, width, height);
                
                for (let i = 0; i < lines.length; i++) {
                    const p1 = lines[i];
                    p1.x += p1.vx;
                    p1.y += p1.vy;
                    if (p1.x < 0 || p1.x > width) p1.vx *= -1;
                    if (p1.y < 0 || p1.y > height) p1.vy *= -1;

                    ctx.beginPath();
                    ctx.arc(p1.x, p1.y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = nodeColor;
                    ctx.fill();

                    for (let j = i + 1; j < lines.length; j++) {
                        const p2 = lines[j];
                        const distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                        if (distance < 150) {
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.strokeStyle = lineColor;
                            ctx.lineWidth = 1 - (distance / 150);
                            ctx.stroke();
                        }
                    }
                }
                requestAnimationFrame(draw);
            }
            
            window.addEventListener('resize', resize);
            resize();
            draw();
        }

        
        });